# 有康企业邮件系统 - 源码解读与使用说明

## 目录

- [系统概述](#系统概述)
- [系统架构](#系统架构)
- [核心组件源码解读](#核心组件源码解读)
  - [MailConfig 邮件配置类](#mailconfig-邮件配置类)
  - [MailTemplate 邮件模板类](#mailtemplate-邮件模板类)
  - [MailUtils 邮件工具类](#mailutils-邮件工具类)
- [配置说明](#配置说明)
- [使用指南](#使用指南)
- [API接口说明](#api接口说明)
- [实际应用场景](#实际应用场景)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 系统概述

有康企业邮件系统是一个基于 Spring Boot Mail 封装的企业级邮件发送解决方案。系统提供了简洁易用的API接口，支持多种邮件发送场景，包括：

- ✅ 纯文本邮件
- ✅ HTML格式邮件
- ✅ 带附件邮件
- ✅ 内嵌图片邮件
- ✅ 群发邮件
- ✅ 模板化邮件

### 技术栈

- Spring Boot 3.5.4
- Spring Boot Mail
- Jakarta Mail API
- Lombok
- SLF4J日志框架

### 主要特性

1. **简单易用**：提供统一的API接口，一行代码即可发送邮件
2. **模板支持**：内置专业的邮件模板，自动生成HTML/文本格式
3. **多场景支持**：覆盖企业常见的所有邮件发送场景
4. **异常处理**：完善的异常处理和日志记录
5. **灵活配置**：支持通过配置文件灵活配置邮件服务器
6. **批量发送**：支持同时发送给多个收件人

---

## 系统架构

### 文件结构

```
youkang-backend-master/
├── youkang-common/
│   └── src/main/java/com/youkang/common/utils/mail/
│       ├── MailTemplate.java         # 邮件模板类
│       ├── MailUtils.java            # 邮件工具类
│       └── MailUsageExample.java     # 使用示例
├── youkang-framework/
│   └── src/main/java/com/youkang/framework/config/
│       └── MailConfig.java           # 邮件配置类
└── youkang-admin/
    └── src/main/resources/
        └── application.yml           # 邮件配置
```

### 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                       业务层 (Service)                        │
│  用户注册、订单通知、系统告警等业务场景                          │
└──────────────────────┬──────────────────────────────────────┘
                       │ 调用
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                    邮件工具层 (MailUtils)                      │
│  ├─ sendSimpleText()          发送纯文本邮件                   │
│  ├─ sendHtml()                发送HTML邮件                    │
│  ├─ sendWithAttachment()      发送带附件邮件                  │
│  ├─ sendTextByTemplate()      使用模板发送文本邮件            │
│  └─ sendHtmlByTemplate()      使用模板发送HTML邮件            │
└──────────────────────┬──────────────────────────────────────┘
                       │ 使用
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                 邮件模板层 (MailTemplate)                      │
│  ├─ generateHtmlContent()     生成HTML格式内容                │
│  └─ generateTextContent()     生成纯文本格式内容              │
└──────────────────────┬──────────────────────────────────────┘
                       │ 基于
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                 Spring Boot Mail (底层)                       │
│  ├─ JavaMailSender              邮件发送器                    │
│  ├─ MimeMessage                 MIME消息                     │
│  └─ MimeMessageHelper           消息辅助类                    │
└──────────────────────┬──────────────────────────────────────┘
                       │ 连接
                       ↓
┌─────────────────────────────────────────────────────────────┐
│                    邮件服务器 (SMTP)                          │
│              QQ邮箱、163邮箱、企业邮箱等                        │
└─────────────────────────────────────────────────────────────┘
```

---

## 核心组件源码解读

### MailConfig 邮件配置类

**文件位置**：`youkang-framework/src/main/java/com/youkang/framework/config/MailConfig.java`

**核心代码解读**：

```java
@Configuration
public class MailConfig {

    @Value("${spring.mail.host}")
    private String host;  // SMTP服务器地址

    @Value("${spring.mail.port}")
    private Integer port;  // SMTP服务器端口

    @Value("${spring.mail.username}")
    private String username;  // 发件邮箱账号

    @Value("${spring.mail.password}")
    private String password;  // 邮箱密码或授权码

    @Bean
    public JavaMailSender javaMailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();

        // 基础配置
        mailSender.setHost(host);
        mailSender.setPort(port);
        mailSender.setUsername(username);
        mailSender.setPassword(password);
        mailSender.setDefaultEncoding("UTF-8");

        // SMTP协议配置
        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.smtp.auth", "true");              // 启用SMTP认证
        props.put("mail.smtp.starttls.enable", "true");   // 启用TLS加密
        props.put("mail.smtp.starttls.required", "true"); // 要求TLS加密
        props.put("mail.smtp.socketFactory.class",
                  "javax.net.ssl.SSLSocketFactory");      // 使用SSL套接字
        props.put("mail.smtp.timeout", "25000");          // 超时时间25秒

        return mailSender;
    }
}
```

**设计要点**：

1. **配置外部化**：所有配置参数通过 `@Value` 从配置文件读取，便于不同环境切换
2. **Bean管理**：将 `JavaMailSender` 注册为Spring Bean，全局单例，避免重复创建
3. **安全配置**：启用TLS/SSL加密，确保邮件传输安全
4. **超时控制**：设置连接超时，避免长时间等待
5. **编码设置**：默认使用UTF-8编码，支持中文邮件

---

### MailTemplate 邮件模板类

**文件位置**：`youkang-common/src/main/java/com/youkang/common/utils/mail/MailTemplate.java`

#### 1. 类设计

```java
@Data
@Builder
public class MailTemplate {
    private String title;              // 邮件标题
    private String recipientName;      // 收件人姓名
    private String content;            // 邮件主要内容
    private String senderName;         // 发件人姓名/公司名称
    private String contactPhone;       // 联系电话（可选）
    private String contactEmail;       // 联系邮箱（可选）

    @Builder.Default
    private Boolean includeTimestamp = true;  // 是否包含时间戳（默认true）
}
```

**设计模式**：使用Builder模式，提供流畅的API调用方式

**示例**：
```java
MailTemplate template = MailTemplate.builder()
    .title("系统通知")
    .recipientName("张三")
    .content("您的账号已激活")
    .senderName("有康科技")
    .build();
```

#### 2. generateHtmlContent() 方法解读

**功能**：生成专业的HTML格式邮件内容

**核心代码结构**：

```java
public String generateHtmlContent() {
    StringBuilder html = new StringBuilder();

    // 1. HTML文档结构
    html.append("<!DOCTYPE html>");
    html.append("<html>");
    html.append("<head>");
    html.append("<meta charset='UTF-8'>");

    // 2. 嵌入CSS样式
    html.append("<style>");
    html.append("body { font-family: 'Microsoft YaHei', Arial, sans-serif; }");
    html.append(".container { max-width: 600px; margin: 0 auto; }");
    html.append(".header { background-color: #4CAF50; color: white; }");
    html.append("</style>");

    // 3. 邮件头部（带标题的绿色横幅）
    html.append("<div class='header'>");
    html.append("<h2>").append(title).append("</h2>");
    html.append("</div>");

    // 4. 问候语
    if (recipientName != null) {
        html.append("尊敬的 <strong>").append(recipientName).append("</strong>：");
    }

    // 5. 主要内容
    html.append("<div class='main-content'>");
    html.append(content);
    html.append("</div>");

    // 6. 页脚（发件人信息）
    html.append("<div class='footer'>");
    html.append(senderName);
    html.append("联系电话：").append(contactPhone);
    html.append("</div>");

    // 7. 时间戳
    if (includeTimestamp) {
        html.append("发送时间：")
            .append(LocalDateTime.now().format(
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
    }

    return html.toString();
}
```

**设计亮点**：

1. **响应式设计**：最大宽度600px，适配各种邮件客户端
2. **样式内联**：CSS样式嵌入在`<style>`标签中，兼容性好
3. **品牌一致性**：统一的绿色主题色（#4CAF50）
4. **可读性优化**：合理的字体、行距、边距设置
5. **信息完整性**：包含标题、内容、联系方式、时间戳等完整信息

#### 3. generateTextContent() 方法解读

**功能**：生成纯文本格式邮件内容（用于不支持HTML的邮件客户端）

**核心代码**：

```java
public String generateTextContent() {
    StringBuilder text = new StringBuilder();

    // 标题
    text.append("【").append(title).append("】\n\n");

    // 问候语
    text.append("尊敬的 ").append(recipientName).append("：\n\n");

    // 主要内容
    text.append(content).append("\n\n");

    // 分隔线
    text.append("----------------------------------------\n\n");

    // 发件人信息
    text.append(senderName).append("\n");
    text.append("联系电话：").append(contactPhone).append("\n");

    // 时间戳
    text.append("\n发送时间：")
        .append(LocalDateTime.now().format(...));

    return text.toString();
}
```

**与HTML版本的差异**：
- 使用换行符 `\n` 控制排版
- 使用分隔线 `--------` 代替样式分隔
- 更简洁，但信息完整

---

### MailUtils 邮件工具类

**文件位置**：`youkang-common/src/main/java/com/youkang/common/utils/mail/MailUtils.java`

#### 1. 类设计

```java
@Component
public class MailUtils {

    @Resource
    private JavaMailSender mailSender;  // 注入邮件发送器

    @Value("${spring.mail.username}")
    private String from;  // 发件人邮箱（从配置读取）

    private static final Logger log = LoggerFactory.getLogger(MailUtils.class);
}
```

**关键点**：
- `@Component`：注册为Spring组件，可被其他类注入使用
- `@Resource`：自动注入`JavaMailSender`
- 日志记录：使用SLF4J记录发送日志和错误信息

#### 2. sendSimpleText() - 发送纯文本邮件

**源码解读**：

```java
public boolean sendSimpleText(String[] toArray, String subject, String content) {
    try {
        // 1. 创建简单邮件消息对象
        SimpleMailMessage message = new SimpleMailMessage();

        // 2. 设置邮件基本信息
        message.setFrom(from);           // 发件人
        message.setTo(toArray);          // 收件人（支持多个）
        message.setSubject(subject);     // 邮件主题
        message.setText(content);        // 邮件内容（纯文本）

        // 3. 发送邮件
        mailSender.send(message);

        // 4. 记录成功日志
        log.info("简单文本邮件发送成功！收件人：{}", Arrays.toString(toArray));
        return true;

    } catch (Exception e) {
        // 5. 记录失败日志
        log.error("简单文本邮件发送失败！收件人：{}, 错误：{}",
                  Arrays.toString(toArray), e.getMessage(), e);
        return false;
    }
}
```

**使用场景**：
- 系统告警通知
- 验证码发送
- 简单的文本提醒

**优点**：
- 发送速度快
- 资源占用少
- 兼容性好

#### 3. sendHtml() - 发送HTML格式邮件

**源码解读**：

```java
public boolean sendHtml(String[] toArray, String subject, String htmlContent) {
    try {
        // 1. 创建MIME消息对象（支持复杂格式）
        MimeMessage message = mailSender.createMimeMessage();

        // 2. 创建消息辅助类
        // 参数说明：
        //   - message: MIME消息对象
        //   - false: 不支持多部分（不支持附件）
        //   - "UTF-8": 字符编码
        MimeMessageHelper helper = new MimeMessageHelper(message, false, "UTF-8");

        // 3. 设置邮件信息
        helper.setFrom(from);
        helper.setTo(toArray);
        helper.setSubject(subject);
        helper.setText(htmlContent, true);  // true表示内容是HTML格式

        // 4. 发送邮件
        mailSender.send(message);

        log.info("HTML邮件发送成功！收件人：{}", Arrays.toString(toArray));
        return true;

    } catch (MessagingException e) {
        log.error("HTML邮件发送失败！收件人：{}, 错误：{}",
                  Arrays.toString(toArray), e.getMessage(), e);
        return false;
    }
}
```

**关键技术点**：

1. **MimeMessage vs SimpleMailMessage**
   - `SimpleMailMessage`：只能发送纯文本
   - `MimeMessage`：支持HTML、附件、内嵌图片等复杂格式

2. **MimeMessageHelper的作用**
   - 简化`MimeMessage`的操作
   - 自动处理字符编码
   - 提供便捷的API

3. **setText()的第二个参数**
   ```java
   helper.setText(content, false);  // 纯文本
   helper.setText(content, true);   // HTML格式
   ```

#### 4. sendWithAttachment() - 发送带附件邮件

**源码解读**：

```java
public boolean sendWithAttachment(String[] toArray, String subject,
                                  String htmlContent, File... attachments) {
    try {
        MimeMessage message = mailSender.createMimeMessage();

        // 关键区别：第二个参数为true，表示支持多部分（附件）
        MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

        helper.setFrom(from);
        helper.setTo(toArray);
        helper.setSubject(subject);
        helper.setText(htmlContent, true);

        // 添加附件
        if (attachments != null && attachments.length > 0) {
            for (File file : attachments) {
                if (file != null && file.exists()) {
                    // 第一个参数：附件在邮件中显示的文件名
                    // 第二个参数：实际的文件对象
                    helper.addAttachment(file.getName(), file);
                    log.info("添加附件：{}", file.getName());
                } else {
                    log.warn("附件不存在或为空：{}",
                             file != null ? file.getName() : "null");
                }
            }
        }

        mailSender.send(message);
        log.info("带附件邮件发送成功！收件人：{}", Arrays.toString(toArray));
        return true;

    } catch (MessagingException e) {
        log.error("带附件邮件发送失败！收件人：{}, 错误：{}",
                  Arrays.toString(toArray), e.getMessage(), e);
        return false;
    }
}
```

**重要细节**：

1. **MimeMessageHelper构造参数**
   ```java
   new MimeMessageHelper(message, false, "UTF-8")  // 不支持附件
   new MimeMessageHelper(message, true, "UTF-8")   // 支持附件
   ```

2. **附件验证**
   - 检查文件是否为null
   - 检查文件是否存在
   - 记录附件添加日志

3. **多附件支持**
   - 使用可变参数 `File... attachments`
   - 支持同时添加多个附件

#### 5. sendHtmlByTemplate() - 使用模板发送邮件

**源码解读**：

```java
public boolean sendHtmlByTemplate(String to, String subject, MailTemplate template) {
    // 调用模板的generateHtmlContent()生成HTML内容
    return sendHtml(to, subject, template.generateHtmlContent());
}
```

**设计模式**：组合模式
- `MailUtils` 负责发送
- `MailTemplate` 负责生成内容
- 两者分离，职责清晰

#### 6. sendWithInlineImage() - 发送内嵌图片邮件

**源码解读**：

```java
public boolean sendWithInlineImage(String to, String subject,
                                   String htmlContent, String imageId, File imageFile) {
    try {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

        helper.setFrom(from);
        helper.setTo(to);
        helper.setSubject(subject);
        helper.setText(htmlContent, true);

        // 添加内嵌图片
        // imageId: HTML中的cid（如：<img src='cid:logo'>）
        // imageFile: 实际的图片文件
        if (imageFile != null && imageFile.exists()) {
            helper.addInline(imageId, imageFile);
        }

        mailSender.send(message);
        log.info("带内嵌图片的邮件发送成功！收件人：{}", to);
        return true;

    } catch (MessagingException e) {
        log.error("带内嵌图片的邮件发送失败！收件人：{}, 错误：{}",
                  to, e.getMessage(), e);
        return false;
    }
}
```

**使用示例**：

```java
// HTML内容
String html = "<html><body>" +
              "<img src='cid:logo' width='200'/>" +  // 使用cid引用
              "<p>欢迎使用有康系统</p>" +
              "</body></html>";

// 发送邮件
mailUtils.sendWithInlineImage(
    "user@example.com",
    "欢迎邮件",
    html,
    "logo",  // imageId，对应HTML中的cid
    new File("D:/logo.png")
);
```

**内嵌图片 vs 附件**：
- **内嵌图片**：直接显示在邮件正文中
- **附件**：需要下载才能查看

---

## 配置说明

### 配置文件位置

`youkang-admin/src/main/resources/application.yml`

### 基础配置

```yaml
spring:
  mail:
    # SMTP服务器地址
    host: smtp.qq.com

    # SMTP服务器端口
    # 常用端口：25（非加密）、465（SSL）、587（TLS）
    port: 465

    # 发件邮箱账号
    username: your-email@qq.com

    # 邮箱密码或授权码
    # 注意：QQ邮箱、163邮箱等需要使用授权码，不是登录密码
    password: your-auth-code

    # 默认编码
    default-encoding: UTF-8

    # SMTP协议配置
    properties:
      mail:
        smtp:
          # 启用SMTP认证
          auth: true

          # 启用TLS加密
          starttls:
            enable: true
            required: true

          # SSL套接字工厂
          socketFactory:
            class: javax.net.ssl.SSLSocketFactory

          # 超时时间（毫秒）
          timeout: 25000
```

### 不同邮箱服务商配置

#### 1. QQ邮箱

```yaml
spring:
  mail:
    host: smtp.qq.com
    port: 465  # 或587
    username: your-qq-email@qq.com
    password: your-qq-auth-code  # QQ邮箱授权码
```

**获取QQ邮箱授权码**：
1. 登录QQ邮箱
2. 设置 → 账户 → POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV服务
3. 开启"POP3/SMTP服务"或"IMAP/SMTP服务"
4. 生成授权码

#### 2. 163邮箱

```yaml
spring:
  mail:
    host: smtp.163.com
    port: 465
    username: your-email@163.com
    password: your-163-auth-code  # 163邮箱授权码
```

#### 3. Gmail（国外）

```yaml
spring:
  mail:
    host: smtp.gmail.com
    port: 587
    username: your-email@gmail.com
    password: your-gmail-app-password
```

#### 4. 企业邮箱

```yaml
spring:
  mail:
    host: smtp.exmail.qq.com  # 腾讯企业邮箱
    port: 465
    username: your-email@yourcompany.com
    password: your-password
```

### 配置验证

启动项目后，查看日志确认邮件配置是否加载成功：

```
INFO  c.y.framework.config.MailConfig - 邮件配置加载成功
INFO  o.s.mail.javamail.JavaMailSenderImpl - JavaMailSender initialized
```

---

## 使用指南

### 基本使用流程

#### 1. 在Service或Controller中注入MailUtils

```java
@Service
public class UserService {

    @Resource
    private MailUtils mailUtils;

    // 业务方法...
}
```

#### 2. 发送邮件

**方式一：直接发送纯文本**

```java
mailUtils.sendSimpleText(
    "user@example.com",
    "测试邮件",
    "这是邮件内容"
);
```

**方式二：使用模板发送HTML邮件**

```java
// 1. 构建模板
MailTemplate template = MailTemplate.builder()
    .title("订单通知")
    .recipientName("张三")
    .content("您的订单已发货")
    .senderName("有康商城")
    .build();

// 2. 发送邮件
mailUtils.sendHtmlByTemplate(
    "zhangsan@example.com",
    "订单发货通知",
    template
);
```

**方式三：发送带附件的邮件**

```java
// 1. 构建模板
MailTemplate template = MailTemplate.builder()
    .title("合同文件")
    .recipientName("王总")
    .content("附件是合作合同，请查收")
    .senderName("有康法务部")
    .build();

// 2. 准备附件
File contract = new File("D:/contract.pdf");

// 3. 发送邮件
mailUtils.sendWithAttachmentByTemplate(
    "wangzong@example.com",
    "合作合同",
    template,
    contract
);
```

### 完整使用示例

```java
@Service
public class OrderService {

    @Resource
    private MailUtils mailUtils;

    /**
     * 订单支付成功后发送邮件通知
     */
    public void sendOrderPaymentNotification(Order order, User user) {
        // 构建邮件模板
        MailTemplate template = MailTemplate.builder()
            .title("订单支付成功")
            .recipientName(user.getNickName())
            .content(String.format(
                "您的订单已支付成功！\n\n" +
                "订单号：%s\n" +
                "订单金额：￥%.2f\n" +
                "支付时间：%s\n\n" +
                "我们将尽快为您安排发货。",
                order.getOrderNo(),
                order.getTotalAmount(),
                order.getPaymentTime()
            ))
            .senderName("有康商城")
            .contactPhone("400-888-6666")
            .contactEmail("service@youkang.com")
            .includeTimestamp(true)
            .build();

        // 发送邮件
        boolean success = mailUtils.sendHtmlByTemplate(
            user.getEmail(),
            "【有康】订单支付成功通知",
            template
        );

        if (success) {
            log.info("订单支付通知邮件发送成功，订单号：{}", order.getOrderNo());
        } else {
            log.error("订单支付通知邮件发送失败，订单号：{}", order.getOrderNo());
        }
    }
}
```

---

## API接口说明

### MailUtils 方法列表

| 方法 | 参数 | 返回值 | 说明 |
|------|------|--------|------|
| `sendSimpleText(String to, String subject, String content)` | to: 收件人<br>subject: 主题<br>content: 内容 | boolean | 发送纯文本邮件（单个收件人） |
| `sendSimpleText(String[] toArray, String subject, String content)` | toArray: 收件人数组<br>subject: 主题<br>content: 内容 | boolean | 发送纯文本邮件（多个收件人） |
| `sendTextByTemplate(String to, String subject, MailTemplate template)` | to: 收件人<br>subject: 主题<br>template: 模板 | boolean | 使用模板发送纯文本邮件 |
| `sendHtml(String to, String subject, String htmlContent)` | to: 收件人<br>subject: 主题<br>htmlContent: HTML内容 | boolean | 发送HTML邮件（单个收件人） |
| `sendHtml(String[] toArray, String subject, String htmlContent)` | toArray: 收件人数组<br>subject: 主题<br>htmlContent: HTML内容 | boolean | 发送HTML邮件（多个收件人） |
| `sendHtmlByTemplate(String to, String subject, MailTemplate template)` | to: 收件人<br>subject: 主题<br>template: 模板 | boolean | 使用模板发送HTML邮件（单个收件人） |
| `sendHtmlByTemplate(String[] toArray, String subject, MailTemplate template)` | toArray: 收件人数组<br>subject: 主题<br>template: 模板 | boolean | 使用模板发送HTML邮件（多个收件人） |
| `sendWithAttachment(String to, String subject, String htmlContent, File... attachments)` | to: 收件人<br>subject: 主题<br>htmlContent: HTML内容<br>attachments: 附件 | boolean | 发送带附件邮件（单个收件人） |
| `sendWithAttachment(String[] toArray, String subject, String htmlContent, File... attachments)` | toArray: 收件人数组<br>subject: 主题<br>htmlContent: HTML内容<br>attachments: 附件 | boolean | 发送带附件邮件（多个收件人） |
| `sendWithAttachmentByTemplate(String to, String subject, MailTemplate template, File... attachments)` | to: 收件人<br>subject: 主题<br>template: 模板<br>attachments: 附件 | boolean | 使用模板发送带附件邮件（单个收件人） |
| `sendWithAttachmentByTemplate(String[] toArray, String subject, MailTemplate template, File... attachments)` | toArray: 收件人数组<br>subject: 主题<br>template: 模板<br>attachments: 附件 | boolean | 使用模板发送带附件邮件（多个收件人） |
| `sendWithInlineImage(String to, String subject, String htmlContent, String imageId, File imageFile)` | to: 收件人<br>subject: 主题<br>htmlContent: HTML内容<br>imageId: 图片ID<br>imageFile: 图片文件 | boolean | 发送内嵌图片邮件 |

### MailTemplate 构建器参数

| 参数 | 类型 | 必填 | 说明 | 示例 |
|------|------|------|------|------|
| `title` | String | 否 | 邮件标题（显示在邮件顶部） | "订单通知" |
| `recipientName` | String | 否 | 收件人姓名 | "张三" |
| `content` | String | 是 | 邮件主要内容 | "您的订单已发货" |
| `senderName` | String | 否 | 发件人姓名或公司名称 | "有康科技有限公司" |
| `contactPhone` | String | 否 | 联系电话 | "400-123-4567" |
| `contactEmail` | String | 否 | 联系邮箱 | "support@youkang.com" |
| `includeTimestamp` | Boolean | 否 | 是否包含时间戳（默认true） | true |

---

## 实际应用场景

### 场景1：用户注册欢迎邮件

```java
@Service
public class UserService {

    @Resource
    private MailUtils mailUtils;

    public void sendWelcomeEmail(User user) {
        MailTemplate template = MailTemplate.builder()
            .title("欢迎加入有康")
            .recipientName(user.getNickName())
            .content(
                "恭喜您成功注册有康账号！\n\n" +
                "现在您可以：\n" +
                "- 浏览和购买商品\n" +
                "- 管理个人信息\n" +
                "- 查看订单历史\n\n" +
                "祝您购物愉快！"
            )
            .senderName("有康客服团队")
            .contactPhone("400-999-8888")
            .contactEmail("service@youkang.com")
            .build();

        mailUtils.sendHtmlByTemplate(
            user.getEmail(),
            "【有康】欢迎您的加入",
            template
        );
    }
}
```

### 场景2：订单状态通知

```java
@Service
public class OrderService {

    @Resource
    private MailUtils mailUtils;

    /**
     * 订单发货通知
     */
    public void sendShipmentNotification(Order order) {
        MailTemplate template = MailTemplate.builder()
            .title("订单发货通知")
            .recipientName(order.getUserName())
            .content(String.format(
                "您的订单已发货！\n\n" +
                "订单号：%s\n" +
                "物流公司：%s\n" +
                "物流单号：%s\n" +
                "预计送达：%s\n\n" +
                "您可以通过物流单号查询物流信息。",
                order.getOrderNo(),
                order.getLogisticsCompany(),
                order.getTrackingNumber(),
                order.getEstimatedDelivery()
            ))
            .senderName("有康物流中心")
            .contactPhone("400-888-6666")
            .build();

        mailUtils.sendHtmlByTemplate(
            order.getUserEmail(),
            "【有康】订单发货通知",
            template
        );
    }
}
```

### 场景3：系统告警通知

```java
@Service
public class SystemMonitorService {

    @Resource
    private MailUtils mailUtils;

    /**
     * 系统异常告警
     */
    public void sendAlertEmail(String errorType, String errorMessage) {
        MailTemplate template = MailTemplate.builder()
            .title("系统告警")
            .recipientName("运维团队")
            .content(String.format(
                "系统检测到异常情况：\n\n" +
                "告警类型：%s\n" +
                "错误信息：%s\n" +
                "发生时间：%s\n\n" +
                "请及时处理！",
                errorType,
                errorMessage,
                LocalDateTime.now().format(
                    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
            ))
            .senderName("有康监控系统")
            .contactPhone("内线：8888")
            .build();

        String[] recipients = {
            "ops1@youkang.com",
            "ops2@youkang.com"
        };

        mailUtils.sendHtmlByTemplate(
            recipients,
            "【告警】系统异常通知",
            template
        );
    }
}
```

### 场景4：发送报表附件

```java
@Service
public class ReportService {

    @Resource
    private MailUtils mailUtils;

    /**
     * 发送月度报表
     */
    public void sendMonthlyReport(String month) {
        MailTemplate template = MailTemplate.builder()
            .title("月度经营报表")
            .recipientName("各部门负责人")
            .content(String.format(
                "您好！\n\n" +
                "附件是%s月度经营报表，请查阅。\n\n" +
                "主要数据概览：\n" +
                "- 营业收入：XXX万元\n" +
                "- 净利润：XXX万元\n" +
                "- 同比增长：XX%%\n\n" +
                "详细数据请查看附件。",
                month
            ))
            .senderName("财务部")
            .contactEmail("finance@youkang.com")
            .build();

        // 准备报表文件
        File report = new File(String.format(
            "D:/reports/%s-monthly-report.xlsx", month));

        String[] recipients = {
            "dept1@youkang.com",
            "dept2@youkang.com",
            "ceo@youkang.com"
        };

        mailUtils.sendWithAttachmentByTemplate(
            recipients,
            String.format("【财务】%s月度报表", month),
            template,
            report
        );
    }
}
```

### 场景5：密码重置邮件

```java
@Service
public class PasswordService {

    @Resource
    private MailUtils mailUtils;

    /**
     * 发送密码重置邮件
     */
    public void sendPasswordResetEmail(User user, String resetToken) {
        String resetUrl = String.format(
            "https://www.youkang.com/reset-password?token=%s", resetToken);

        MailTemplate template = MailTemplate.builder()
            .title("密码重置")
            .recipientName(user.getNickName())
            .content(String.format(
                "您好！\n\n" +
                "我们收到了您的密码重置请求。\n\n" +
                "请点击以下链接重置密码：\n" +
                "%s\n\n" +
                "此链接将在30分钟后失效。\n\n" +
                "如果这不是您的操作，请忽略此邮件。",
                resetUrl
            ))
            .senderName("有康安全中心")
            .contactEmail("security@youkang.com")
            .build();

        mailUtils.sendHtmlByTemplate(
            user.getEmail(),
            "【有康】密码重置请求",
            template
        );
    }
}
```

---

## 最佳实践

### 1. 异步发送邮件

邮件发送通常耗时较长（1-3秒），建议使用异步方式，避免阻塞主线程。

```java
@Service
public class UserService {

    @Resource
    private MailUtils mailUtils;

    @Async  // 使用Spring异步注解
    public void sendWelcomeEmailAsync(User user) {
        MailTemplate template = MailTemplate.builder()
            .title("欢迎加入")
            .recipientName(user.getNickName())
            .content("欢迎注册！")
            .senderName("有康")
            .build();

        mailUtils.sendHtmlByTemplate(
            user.getEmail(),
            "欢迎邮件",
            template
        );
    }
}
```

**配置异步支持**：

```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("mail-async-");
        executor.initialize();
        return executor;
    }
}
```

### 2. 邮件发送失败重试

```java
@Service
public class MailService {

    @Resource
    private MailUtils mailUtils;

    /**
     * 带重试机制的邮件发送
     */
    public boolean sendEmailWithRetry(String to, String subject,
                                      MailTemplate template, int maxRetries) {
        int attempts = 0;

        while (attempts < maxRetries) {
            boolean success = mailUtils.sendHtmlByTemplate(to, subject, template);

            if (success) {
                return true;
            }

            attempts++;
            log.warn("邮件发送失败，第{}次重试", attempts);

            // 等待后重试
            try {
                Thread.sleep(2000 * attempts);  // 递增等待时间
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        log.error("邮件发送失败，已重试{}次", maxRetries);
        return false;
    }
}
```

### 3. 邮件模板管理

**建议**：将常用的邮件模板封装成独立的方法

```java
@Component
public class MailTemplateFactory {

    /**
     * 生成欢迎邮件模板
     */
    public MailTemplate createWelcomeTemplate(String userName) {
        return MailTemplate.builder()
            .title("欢迎加入有康")
            .recipientName(userName)
            .content("恭喜您成功注册...")
            .senderName("有康客服团队")
            .contactPhone("400-999-8888")
            .build();
    }

    /**
     * 生成订单通知模板
     */
    public MailTemplate createOrderTemplate(String userName, Order order) {
        return MailTemplate.builder()
            .title("订单通知")
            .recipientName(userName)
            .content(String.format("订单号：%s\n金额：%.2f",
                order.getOrderNo(), order.getTotalAmount()))
            .senderName("有康商城")
            .build();
    }
}
```

### 4. 邮件发送记录

**建议**：记录邮件发送历史，便于追踪和审计

```java
@Service
public class MailRecordService {

    @Resource
    private MailUtils mailUtils;

    @Resource
    private MailRecordMapper mailRecordMapper;

    /**
     * 发送邮件并记录
     */
    public boolean sendAndRecord(String to, String subject, MailTemplate template) {
        // 1. 发送邮件
        boolean success = mailUtils.sendHtmlByTemplate(to, subject, template);

        // 2. 记录发送历史
        MailRecord record = new MailRecord();
        record.setRecipient(to);
        record.setSubject(subject);
        record.setContent(template.generateHtmlContent());
        record.setSendTime(LocalDateTime.now());
        record.setStatus(success ? "SUCCESS" : "FAILED");

        mailRecordMapper.insert(record);

        return success;
    }
}
```

### 5. 邮件内容安全

**注意事项**：
- 避免在邮件中包含敏感信息（如密码）
- 对用户输入的内容进行HTML转义，防止XSS攻击

```java
import org.springframework.web.util.HtmlUtils;

public String sanitizeContent(String userInput) {
    // HTML转义
    return HtmlUtils.htmlEscape(userInput);
}
```

### 6. 批量发送优化

**建议**：对于大批量发送，使用批次处理

```java
@Service
public class BatchMailService {

    @Resource
    private MailUtils mailUtils;

    /**
     * 批量发送邮件（分批处理）
     */
    public void sendBatchEmails(List<String> recipients,
                                String subject, MailTemplate template) {
        int batchSize = 50;  // 每批50个

        for (int i = 0; i < recipients.size(); i += batchSize) {
            int end = Math.min(i + batchSize, recipients.size());
            List<String> batch = recipients.subList(i, end);

            // 发送一批
            mailUtils.sendHtmlByTemplate(
                batch.toArray(new String[0]),
                subject,
                template
            );

            // 批次间隔，避免被封
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

---

## 常见问题

### Q1：邮件发送失败，提示"Authentication failed"

**原因**：邮箱密码或授权码错误

**解决方案**：
1. 检查配置文件中的 `spring.mail.username` 和 `spring.mail.password`
2. 确认使用的是**授权码**，不是登录密码（QQ邮箱、163邮箱等）
3. 重新生成授权码并更新配置

### Q2：邮件发送成功，但收件箱收不到

**可能原因**：
1. 邮件被当作垃圾邮件过滤
2. 发件人邮箱信誉度低
3. 收件人邮箱地址错误

**解决方案**：
1. 检查垃圾邮件箱
2. 将发件人添加到通讯录/白名单
3. 查看发送日志，确认发送成功
4. 检查收件人邮箱地址是否正确

### Q3：发送HTML邮件，样式不生效

**原因**：部分邮件客户端不支持外部CSS或某些CSS属性

**解决方案**：
1. 使用内联样式（style属性）
2. 避免使用复杂的CSS（如flexbox、grid）
3. 使用表格布局（`<table>`）
4. 测试多个邮件客户端

### Q4：附件过大导致发送失败

**原因**：邮件服务器有附件大小限制（通常10-25MB）

**解决方案**：
1. 压缩附件
2. 使用云存储，邮件中发送下载链接
3. 分多封邮件发送

### Q5：如何发送给密送（BCC）收件人？

```java
MimeMessage message = mailSender.createMimeMessage();
MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

helper.setFrom(from);
helper.setTo("recipient@example.com");  // 收件人
helper.setBcc("bcc@example.com");       // 密送
helper.setSubject(subject);
helper.setText(content, true);

mailSender.send(message);
```

### Q6：如何设置邮件优先级？

```java
MimeMessage message = mailSender.createMimeMessage();
MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");

// 设置为高优先级
helper.setPriority(1);  // 1=高, 3=普通, 5=低

mailSender.send(message);
```

### Q7：邮件发送很慢怎么办？

**优化方案**：
1. 使用异步发送（`@Async`）
2. 使用消息队列（RabbitMQ、Kafka）
3. 优化附件大小
4. 使用邮件发送服务（如SendGrid、阿里云邮件推送）

### Q8：如何测试邮件功能？

**方法1**：使用真实邮箱测试
- 配置一个测试邮箱
- 发送到自己的邮箱

**方法2**：使用邮件测试工具
- [MailHog](https://github.com/mailhog/MailHog)：本地邮件测试工具
- [Mailtrap](https://mailtrap.io/)：在线邮件测试服务

**方法3**：单元测试

```java
@SpringBootTest
class MailUtilsTest {

    @Resource
    private MailUtils mailUtils;

    @Test
    void testSendSimpleText() {
        boolean success = mailUtils.sendSimpleText(
            "test@example.com",
            "测试邮件",
            "这是测试内容"
        );

        assertTrue(success);
    }
}
```

---

## 总结

有康企业邮件系统是一个功能完善、易于使用的邮件发送解决方案。通过 `MailTemplate` 和 `MailUtils` 的组合使用，可以快速实现各种邮件发送场景。

**核心优势**：
- ✅ 简洁的API设计
- ✅ 专业的邮件模板
- ✅ 完善的异常处理
- ✅ 详细的日志记录
- ✅ 灵活的配置方式

**适用场景**：
- 用户注册/登录通知
- 订单状态变更通知
- 系统告警通知
- 营销邮件发送
- 报表定期推送
- 密码重置邮件

**建议**：
- 生产环境使用企业邮箱或专业邮件服务
- 重要邮件实现发送失败重试机制
- 记录邮件发送历史便于追踪
- 使用异步方式提高系统响应速度

如有问题或建议，请联系技术支持团队。

---

**文档版本**：v1.0
**最后更新**：2025-11-27
**维护者**：有康技术团队
